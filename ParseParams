#!/bin/bash

#source utility
source ./tools
sourced || die 'ParseParams must only be sourced'

#############################################################################
# Sanity checks

#----------------------------------------------------------------------------
# Check version of getopt.

# Wrapping this in a function allows us to test this with bats.

verify_getopt() {
  getopt -T &> /dev/null
  [[ $? -eq 4 ]] || die 1 "Unsupported version of getopt!"
}

# Why is this killing tests?!
#verify_getopt

#----------------------------------------------------------------------------
# Turn on extended globbing
shopt -s extglob

#############################################################################
# Documentation

: << POD
=head1 NAME

ParseParams - Parse command line or function parameters.

=head1 SYNOPSIS

  source ParseParams

  PARM_DEF='
  a|app,string,AppName,,required
  b|bank,number,BankNumber
  c,boolean
  '
  parse_params "$PARM_DEF" "$@"

=head1 OPTIONS

There are no options for sourcing the library itself. For the C<parse_params>
function, the following describes the required input.

The first parameter is the parameter definition string, described below.

The remaining parameters are the input parameters to be validated.

NOTE: Not explicitly including "\$@" is allowed but this scenario has not been
tested.

=head1 DESCRIPTION

The ParseParams library takes a definition string and validates input
parameters against that definition, setting variables to those values if they
pass the various checks. Otherwise an error message is returned and the
calling script is exited.

=head1 TYPES

=over

=item boolean

This creates a switch parameter. The variable is set to 1 if it is not passed
on the command line, otherwise it is set to 0.

=item string

This just checks for a non-empty value.

=item char

Requires a single character for the value.

=item integer

Requires the value be a positive integer.

=back

=head2

You can add your own type checking by adding a function or application name to
the TYPES array.

  mycheck() { true; }

  source ParseParams

  TYPES['mytype']='mycheck'

  parse_params "definition string" "parameters"

C<mycheck> must return 0 for a passing check, or a 1 for a failed check. Any
output is ignored.

=head1 DEFINITION STRING

Usage:

  source ParseParams

  PARM_DEF='
  a|app,string,AppName,,required
  b|bank,number,BankNumber
  c,boolean
  '
  parse_params "$PARM_DEF" "$@"

XXX FIX ME!!!

The variable name defined by the definition line will be set to the matching
input value.

The remaining parameters are the input values that need to be validated.

A definition line is made up of five (5) fields, separated by commas and/or
spaces:

B<OPTION, TYPE, VARNAME, DEFAULT, REQUIRED>

B<OPTION> and B<TYPE> are required. A minimal definition line would look like:

  a,appname

The variable named C<a> would be set to C<appname>.

The remaining three fields are optional. If you want to provide a default
value, but not make the parameter required or have a different varname, your
definition line would look like:

  a|app,string,,appname

If no parameter was used on the command line, C<app> would be set to
C<appname>.

Another possible definition is to set the first field to '#'. This will cause
C<parse_params> to look for positional parameters. Since these are checked for
last, any definitions with the same variable name will be overwritten with the
positional value.

=head3 OPTION

B<OPTION> is a required field and can be any string.

B<OPTION> can define a short option--a dash (-) followed by a single character,
a long option--a double dash (--) followed by a string, or a short option and
a long option separated by a pipe (|).

If B<VARNAME> is not provided then B<VARNAME> will be set to the long option
if it exists, or the short option if it does not.

=head3 TYPE

B<TYPE> is a required field and can be any of the types defined in the
C<TYPES> section. See that section for what each type does.

If B<TYPE> is C<boolean>, the B<REQUIRED> field is forced to be C<optional> and
B<VARNAME> is forced to be either C<0> (true) or C<1> (false).

If B<TYPE> is C<boolean> it does not make sense to have a default setting. If
the switch is not used on the command line B<VARNAME> will be 1. If
B<VARNAME> is used on the command line it will be 0.

If a default is set in the parameter definition, it will be ignored.

=head3 VARNAME

B<VARNAME> is optional and will default to the long option, or if none
provided, the short option.

B<VARNAME> will be set to the matching input parameter.

=head3 DEFAULT

B<DEFAULT> is optional.

IF B<DEFAULT> is set and the parameter is not used on the command line,
B<VARNAME> will be set to the matching input parameter. Otherwise B<VARNAME>
will be set to C<NULL>, except for type C<boolean> as described above.

=head3 REQUIRED

B<REQUIRED> is optional and will default to C<optional>.

B<REQUIRED> can be either C<required> or C<optional> and is case insensitive.
I.e., C<required>, C<REQUIRED> and C<Required> are identical.

If B<REQUIRED> is C<required> the parameter must be included on the command
line.


=cut
POD

#############################################################################
# Globals

# The character to be used for a position definition. This should be
# a 1 character length string.
declare POS_DEF='#' # If you change this make sure you update the documentation!
declare SHORTOPTS LONGOPTS DEF_LINES
declare -i ERR=0
declare -a POS_LINES
declare -A TYPES

declare nl=$'\n'

# Boolean types are handled as a special case.

TYPES['boolean']=''

# These functions are defined in the utility library loaded at the top of this
# script.

TYPES['string']='is_string'
TYPES['char']='is_char'
TYPES['integer']='is_integer'

#############################################################################
# Main function

: << POD
=head1 FUNCTIONS

=head2 parse_params

Expects the first parameter to be a format string that defines options and
types so that parameters can be validated, to a minimal degree. The developer
can validate parameters for their specific needs.

=cut
POD

# Expects a definition string to be passed as a single parameter.

function parse_params() {
  [[ $# -eq 0 ]] && die 'No definitions were passed to parse_params.'

  _build_parms_info "$1"
  shift

  eval "$(_build_eval_string)"

  _parse_params "$@" || {
    warn "Problems parsing parameters."
    return 1
  }

  ((ERR)) && {
    warn 'Some weird problem happened.'
    return 1
  }

  return 0
}

#############################################################################
: << POD
=head1 INTERNAL FUNCTIONS

These functions should not be called unless you know exactly what you are
doing.

=cut
POD

#----------------------------------------------------------------------------
: << POD
=head2 _valid_varname

=over

=item usage: _valid_varname 'varname'

=back

Checks if varname is a valid variable name. Returns 0 if it is, 1 if it's not.

A valid variable name starts with an underscore and an alpha character. The
remaining characters can be an underscore or a alphanumeric character.

=cut
POD

_valid_varname() {
  # If varname is a single character then it can't be an underscore '_'.
  [[ $1 == [A-Za-z] ]] && return 0
  [[ $1 == [A-Za-z_][A-Za-z0-9_]* ]] && return 0
  return 1
}

#----------------------------------------------------------------------------
: << POD
=head2 _check_type

=over

=item usage: _check_type typename variablename

=back

Checks the value of a variable with the type check in the TYPES array.

=cut
POD

# XXX: Should we be returning > 1 instead of dying here?

function _check_type() {
  [[ $# -eq 2 ]] || die 'must pass type name and value to _check_type'
  [[ -z $1 ]] && die 'cannot pass empty type to _check_type'

  local -l type="$1"
  local variable="$2"

  debug "type: $type"
  debug "variable: $variable"

  [[ $type == 'boolean' ]] && die "Invalid type ($type is handled differently)"

  # This fails if $type doesn't exist or is null (TYPES[$type]=) or empty
  # (TYPES[$type]='').

  [[ -n ${TYPES[$type]} || -z ${TYPES[$type]-foo} ]] \
    || die "Invalid type ($type), it must exist and not be null or empty"

  local func="${TYPES[$type]}"

  is_executable "$func" \
    || die "$func does not appear to be a command or function"

  # We *want* the output of the $(call) to be executed!
  debug "$func ${variable}"
  # shellcheck disable=SC2091
  $("$func" "$variable")
}

#----------------------------------------------------------------------------
: << POD
=head2 _build_parms_info

Normalizes the various ways a definition string can be defined into
a stricter, normalized string for use in C<_build_eval_string> below.

=cut
POD

# Expects a definition string to be passed as a single parameter.

# Sets DEF_LINES and POS_LINES (if any are included) to normalized definition
# lines.

# Sets SHORTOPTS and LONGOPTS to required values.

function _build_parms_info() {
  [[ -z $1 ]] && die 'No definitions were passed to _build_parms_info.'

  local OPTION VAR DEFAULT
  local -l TYPE REQ

  IFS=$nl readarray -t def_lines <<< "$1"

  for BPI_IX in "${!def_lines[@]}"; do
    [[ -z ${def_lines[BPI_IX]} ]] && continue

    line="${def_lines[BPI_IX]}"
    errline="on definition line $BPI_IX ($line)"
    debug "$errline"

    # The definition line is separated by commas
    IFS=', ' read -r OPTION TYPE VAR DEFAULT REQ <<< "$line"

    # The options can have one or more choices
    IFS='|' read -ra OPTIONS <<< "$OPTION"

    debug "OPTIONS: ${OPTIONS[*]}"
    debug "TYPE: $TYPE"
    debug "VAR: $VAR"
    debug "DEFAULT: $DEFAULT"
    debug "REQ: $REQ"

    #------------------------------------------------------------------------
    [[ -z $REQ ]] && REQ='optional'

    [[ $REQ =~ required|optional ]] \
      || die "Only 'required', 'optional' or null is valid $errline."

    #------------------------------------------------------------------------
    # Default to string if not included
    [[ -z $TYPE ]] && TYPE='string'

    [[ -n ${TYPES[$TYPE]} || -z ${TYPES[$TYPE]-foo} ]] \
      || die "Invalid type ($TYPE) $errline."

    [[ $TYPE == 'boolean' ]] && REQ='optional'

    #------------------------------------------------------------------------
    [[ $OPTION == *$POS_DEF* ]] && [[ ${#OPTIONS[@]} -gt 1 ]] \
      && die "'$POS_DEF' must be the only option $errline."

    if [[ $OPTION == "$POS_DEF" ]]; then
      # XXX: Include in docs the following
      # DEFAULT and REQUIRED are silently ignored
      [[ -z $VAR ]] && die "Variable name is required when using position $errline."
      POS_LINES+=("$TYPE,$VAR")
      continue

    else
      # Default variable name to last option if not included.
      [[ -z $VAR ]] && VAR="${OPTIONS[-1]}"
      _valid_varname "$VAR" \
        || die "Invalid variable name ($VAR) $errline."
    fi

    #------------------------------------------------------------------------
    # If a default value is provided, does it pass the type check?
    if [[ -n $DEFAULT ]]; then
      _check_type "$TYPE" "$DEFAULT" \
        || die "default value ($DEFAULT) does not pass type check $errline."
    fi

    #------------------------------------------------------------------------
    # From getopt manpage: A short option "may be followed by one colon to
    # indicate it has a required argument, and by two colons to indicate it
    # has an optional argument". The same holds true for long options.

    # We are currently not supporting an optional argument.

    for opt in "${OPTIONS[@]}"; do
      if [[ $opt =~ ^[[:alnum:]]$ ]]; then
        [[ $SHORTOPTS == *"$opt"* ]] && die "Repeated short option ($opt) $errline."
        SHORTOPTS+="$opt"
        [[ $TYPE != 'boolean' ]] && SHORTOPTS+=':'

      elif [[ $opt =~ ^[[:alnum:]]+$ ]]; then
        [[ $LONGOPTS == *"$opt"* ]] && die "Repeated long option ($opt) $errline."
        LONGOPTS+="$opt"
        [[ $TYPE != 'boolean' ]] && LONGOPTS+=':,'

      else
        die "Invalid option ($opt) on line $BPI_IX."
      fi
    done

    DEF_LINES+=$(printf '%s,' "$OPTION" "$TYPE" "$VAR" "$DEFAULT" "$REQ")
    DEF_LINES="${DEF_LINES%%,}"
    DEF_LINES+=$nl
  done

  # Get rid of trailing ','
  LONGOPTS="${LONGOPTS%%,}"

  debug "DEF_LINES: $DEF_LINES <"
  debug "POS_LINES: ${POS_LINES[*]} <"
  debug "$(printf '%-15s - %-15s <' 'SHORTOPTS' 'LONGOPTS')"
  debug "$(printf '%-15s - %-15s <' "$SHORTOPTS" "$LONGOPTS")"

  return 0
}

#----------------------------------------------------------------------------
: << POD
=head2 _build_eval_string

Builds a string that will be eval'd and defines the C<_parse_params> function
based on the definition lines passed to C<parse_params>.

=head2 _parse_params

This is a dynamic function, built on the fly as a string and eval'd and then
called in C<parse_params>.

=cut
POD

function _build_eval_string() {
  if [[ -z $DEF_LINES ]] && [[ ${#POS_LINES[@]} -eq 0 ]]; then
    die "Either DEF_LINES or POS_LINES needs to be set."
  fi

  local OPTION VAR DEFAULT DEFAULTS_STRING REQUIRED_STRING CASE_STRING
  local -l TYPE REQ

  IFS=$nl readarray -t def_lines <<< "$DEF_LINES"

  for BES_IX in "${!def_lines[@]}"; do
    [[ -z ${def_lines[BES_IX]} ]] && continue

    debug "line $BES_IX: $(printf '%s' "${def_lines[BES_IX]}")"

    IFS=',' read -r OPTION TYPE VAR DEFAULT REQ <<< "${def_lines[BES_IX]}"
    #debug "OPTION: $OPTION ::: TYPE: $TYPE ::: VAR: $VAR ::: DEFAULT: $DEFAULT ::: REQ: $REQ <"

    CASE_STRING+="$nl"

    if [[ $OPTION =~ ^[[:alnum:]]$ ]]; then
      CASE_STRING+="-$OPTION)$nl"
    elif [[ $OPTION != *"|"* ]]; then
      CASE_STRING+="--$OPTION)$nl"
    else
      CASE_STRING+="-${OPTION/|/ | \-\-})$nl"
    fi

    CASE_STRING+="debug \"case: $OPTION \$(printf '%s' \$2)\"$nl"

    if [[ $TYPE == 'boolean' ]]; then
      CASE_STRING+="$VAR=0$nl"
      CASE_STRING+="shift$nl"

      DEFAULT=1
    else
      CASE_STRING+="$VAR=\"\$2\"$nl"
      CASE_STRING+="shift 2$nl"

      VALIDATE_STRING+="_check_type '$TYPE' '$VAR' || { warn \"$OPTION (\$$VAR) is not a $TYPE.\"; ((ERR++)); }$nl"
    fi

    CASE_STRING+=";;$nl"

    if [[ -n $DEFAULT ]]; then
      DEFAULTS_STRING+="$VAR='$DEFAULT'$nl"
    fi

    if [[ $REQ == 'required' ]]; then
      REQUIRED_STRING+="[[ -n \$$VAR ]] || { warn '$VAR ($OPTION) is required.'; ((ERR++)); }$nl"
    fi

    DEBUG_STRING+="debug \"(after case) $VAR: \$$VAR\"$nl"

  done

  if [[ -n $CASE_STRING ]]; then
    CASE_STRING="
  local gopts=\"--alternative\"
  [[ -n \$SHORTOPTS ]] && gopts=\"\$gopts --options \$SHORTOPTS\"
  [[ -n \$LONGOPTS ]] && gopts=\"\$gopts --longoptions \$LONGOPTS\"

  debug \"gopts: \$gopts\"

  ARGS=\"\$(getopt \$gopts -- \"\$@\")\" || {

    # From man page for getopt:
    # getopt returns error code 0 for successful parsing, 1 if getopt(3) returns
    # errors, 2 if it does not understand its own parameters, 3 if an internal
    # error occurs like out-of-memory, and 4 if it is called with -T.

    rc=\$?

    ((rc==4)) && die \"Don't call getopt with '-T'.\"
    ((rc==3)) && die \"getopt internal error.\"
    ((rc==2)) && die \"Unrecognized parameters used with getopt.\"
  }

  debug \"ARGS: \$(printf '%s' \"\$ARGS\")\"

  eval set -- \"\$ARGS\"

  while true; do
    #debug \"1: \$1 ::: 2: \$2\"

    case \"\$1\" in
$CASE_STRING
      --)
        debug 'case: --'
        shift
        break
        ;;

      *)
        debug 'case: *'
        break ;;
    esac
  done
"
  fi

  # This eval will execute arbitrary code from the command line. Don't use it!
  #[[ -n \$1 ]] && eval \"\$VAR=\$1\"

  if [[ ${#POS_LINES[@]} -gt 0 ]]; then
    POS_STRING="
  for PL_IX in \"\${!POS_LINES[@]}\"; do
    IFS=',' read -r TYPE VAR <<< \"\${POS_LINES[PL_IX]}\"
    [[ -n \$1 ]] && IFS= read -r \"\$VAR\" <<< \"\$1\"
    debug \"(in pos loop) \$VAR: \${!VAR}\"
    _check_type \"\$TYPE\" \"\$VAR\" || { warn \"'\${!VAR}' (position \$PL_IX) is not a \$TYPE\"; ((ERR++)); }
    shift
  done
"
  fi

  local EVAL_STRING="
_parse_params() {
$DEFAULTS_STRING
$CASE_STRING
$POS_STRING
$DEBUG_STRING
$REQUIRED_STRING
$VALIDATE_STRING

  debug \"ERR: \$ERR\"
  ((ERR)) && return 1
  return 0
}
"

  debug "$(echo "$EVAL_STRING" | shfmt -s -i 2 -bn -ci -sr)"
  printf '%s' "$EVAL_STRING"
}

return 0
